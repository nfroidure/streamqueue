[//]: # ( )
[//]: # (This file is automatically generated by a `metapak`)
[//]: # (module. Do not change it  except between the)
[//]: # (`content:start/end` flags, your changes would)
[//]: # (be overridden.)
[//]: # ( )
# streamqueue
> StreamQueue pipe the queued streams one by one in order to preserve their content order.

[![GitHub license](https://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/nfroidure/streamqueue/blob/main/LICENSE)


[//]: # (::contents:start)

## Usage

Install the [npm module](https://npmjs.org/package/streamqueue):

```sh
npm install streamqueue --save
```

Then, in your scripts:

```js
import { StreamQueue } from 'streamqueue';
import { createReadStream } from 'node:fs';

const queue = new StreamQueue(
  createReadStream('input.txt'),
  createReadStream('input2.txt'),
  createReadStream('input3.txt'),
).pipe(process.stdout);
```

StreamQueue also accept functions returning streams, the above can be written
like this, doing system calls only when piping:

```js
import { queueStreams } = require('streamqueue');
import { createReadStream } from 'node:fs';

const queue = queueStreams(
  createReadStream.bind(null, 'input.txt'),
  createReadStream.bind(null, 'input2.txt'),
  createReadStream.bind(null, 'input3.txt'),
).pipe(process.stdout);
```

Object-oriented traditionnal API offers more flexibility:

```js
import { StreamQueue } from 'streamqueue';
import { createReadStream } from 'node:fs';

const queue = new StreamQueue();

queue.queue(
  createReadStream('input.txt'),
  createReadStream('input2.txt'),
  createReadStream('input3.txt'),
);
queue.done();

queue.pipe(process.stdout);
```

You can also chain StreamQueue methods like that:

```js
import StreamQueue from 'streamqueue';
import { createReadStream } from 'node:fs';

new StreamQueue()
  .queue(createReadStream('input.txt'))
  .queue(createReadStream('input2.txt'))
  .queue(createReadStream('input3.txt'))
  .done()
  .pipe(process.stdout);
```

You can queue new streams at any moment until you call the done() method. So the
created stream will not fire the end event until done() call.

## Stats

[![NPM](https://nodei.co/npm/streamqueue.png?downloads=true&stars=true)](https://nodei.co/npm/streamqueue/)
[![NPM](https://nodei.co/npm-dl/streamqueue.png)](https://nodei.co/npm/streamqueue/)

## Contributing

Feel free to propose your code if you agree with publishing it under the MIT
license.

[//]: # (::contents:end)

# API
## Classes

<dl>
<dt><a href="#StreamQueue">StreamQueue</a></dt>
<dd><p>Pipe queued streams sequentially</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#queueObjectStreams">queueObjectStreams(options, ...streams)</a> ⇒</dt>
<dd><p>Create a new queue in object mode and pipe given streams and end if some</p>
</dd>
<dt><a href="#queueStreams">queueStreams(options, ...streams)</a> ⇒</dt>
<dd><p>Create a new queue and pipe given streams and end if some</p>
</dd>
</dl>

<a name="StreamQueue"></a>

## StreamQueue
Pipe queued streams sequentially

**Kind**: global class  

* [StreamQueue](#StreamQueue)
    * [new StreamQueue(options, ...streams)](#new_StreamQueue_new)
    * [.queue(...streams)](#StreamQueue+queue) ⇒
    * [.done(...streams)](#StreamQueue+done) ⇒

<a name="new_StreamQueue_new"></a>

### new StreamQueue(options, ...streams)
Create a new queue and pipe given streams and end if some

**Returns**: StreamQueue  

| Param | Type | Description |
| --- | --- | --- |
| options | <code>Object</code> | The queue options |
| options.objectMode | <code>boolean</code> | Operate in object mode |
| options.pauseFlowingStream | <code>boolean</code> | Pause given streams that are flowing |
| options.resumeFlowingStream | <code>boolean</code> | Resume given streams that are flowing |
| ...streams | <code>Readable</code> \| <code>function</code> | The stream or stream returning function to pipe in |

<a name="StreamQueue+queue"></a>

### streamQueue.queue(...streams) ⇒
Queue each stream given in argument

**Kind**: instance method of [<code>StreamQueue</code>](#StreamQueue)  
**Returns**: StreamQueue  

| Param | Type | Description |
| --- | --- | --- |
| ...streams | <code>Readable</code> \| <code>function</code> | The stream or stream returning function to pipe in |

<a name="StreamQueue+done"></a>

### streamQueue.done(...streams) ⇒
Queue each stream given in argument and end

**Kind**: instance method of [<code>StreamQueue</code>](#StreamQueue)  
**Returns**: StreamQueue  

| Param | Type | Description |
| --- | --- | --- |
| ...streams | <code>Readable</code> \| <code>function</code> | The stream or stream returning function to pipe in |

<a name="queueObjectStreams"></a>

## queueObjectStreams(options, ...streams) ⇒
Create a new queue in object mode and pipe given streams and end if some

**Kind**: global function  
**Returns**: StreamQueue  

| Param | Type | Description |
| --- | --- | --- |
| options | <code>Object</code> | The queue options |
| ...streams | <code>Readable</code> \| <code>function</code> | The stream or stream returning function to pipe in |

<a name="queueStreams"></a>

## queueStreams(options, ...streams) ⇒
Create a new queue and pipe given streams and end if some

**Kind**: global function  
**Returns**: StreamQueue  

| Param | Type | Description |
| --- | --- | --- |
| options | <code>Object</code> | The queue options |
| ...streams | <code>Readable</code> \| <code>function</code> | The stream or stream returning function to pipe in |


# Authors
- [Nicolas Froidure](https://insertafter.com/en/index.html)

# License
[MIT](https://github.com/nfroidure/streamqueue/blob/main/LICENSE)
